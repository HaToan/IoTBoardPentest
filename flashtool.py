import argparse
from pyftdi.ftdi import Ftdi

from pyftdi.spi import SpiController

version = 1.0

def getParams():
    parser = argparse.ArgumentParser(description="flashtool.py -i ftdi://ftdi:2232:0:2/1", formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('-V', '--version', action='store_true', help='show version')
    parser.add_argument('-i', '--interface', help='Select interface')
    parser.add_argument('-l', '--listd', action='store_true', help='Show Devices')
    parser.add_argument('-fid', '--flashid', action='store_true', help = 'Show ID Flash')

    functional_group = parser.add_argument_group(
        'Function Options', 'Specify what operation to run.')
    functional_group.add_argument(
        '-r', '--read', action='store_true', help='read all NAND Flash')
    functional_group.add_argument(
        '-w', '--write', action='store_true', help='write NAND from a raw dump')
    functional_group.add_argument(
        '-e', '--erase', action='store_true', help='erase blocks')
    functional_group.add_argument(
        '--write_value', action='store', help='fill the NAND with this value.', type=int)
    functional_group.add_argument(
        '--write_pgm', action='store_true',
        help='use a .pgm source image file. Will write the image over and over until the end.')
    functional_group.add_argument(
        '--start', action='store', type=int, default=0,
        help=('Set a start bound for the operation. This bound is included:  range(start, end)'
                '(for a read or write operation, the unit is a page, for Erase, it is a block'))
    functional_group.add_argument(
        '--end', action='store', type=int, default=None,
        help=('Set a end number for the operation. This bound is excluded: range(start, end)'
                '(for a read or write operation, the unit is a page, for Erase, it is a block'))

    geometry_group = parser.add_argument_group(
        'Geometry options',
        'Specify the geometry of the NAND flash if it can\'t be detected via ONFI.')
    geometry_group.add_argument(
        '-P', '--page_size', action='store',
        help='specify page size and OOB size in bytes, with the format: "2048,128"')
    geometry_group.add_argument(
        '-B', '--pages_per_block', action='store', help='number of pages per block')
    geometry_group.add_argument(
        '-K', '--number_of_blocks', action='store', help='total number of blocks')


    args = parser.parse_args()
    return args

def getDevices():
    Ftdi.show_devices()

def getID(interface):
    # Instantiate a SPI controller
    spi = SpiController()

    # Configure the first interface (IF/1) of the FTDI device as a SPI master
    spi.configure(interface)

    # Get a port to a SPI slave w/ /CS on A*BUS3 and SPI mode 0 @ 12MHz
    slave = spi.get_port(cs=0, freq=12E6, mode=0)
    if(not slave):
        return -1
    # Request the JEDEC ID from the SPI slave
    jedec_id = slave.exchange([0x9f], 3)
    print("Manufacture Jedec ID: ", jedec_id.hex())
    return jedec_id

class FlashProfile:
    def __init__():
        pass

    def read():
        pass

    def write():
        pass


if __name__ == "__main__":
    args = getParams()

    if (args.version ): print("FlashTool Version: ", version)
    elif (args.listd): getDevices()
    elif (args.flashid and args.interface):
        getID(args.interface)
    else:
        getDevices()